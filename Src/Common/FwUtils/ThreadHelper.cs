// Copyright (c) 2010-2013 SIL International
// This software is licensed under the LGPL, version 2.1 or later
// (http://www.gnu.org/licenses/lgpl-2.1.html)
//
// File: ThreadHelper.cs
// Responsibility: FW TEam

using System;
using System.ComponentModel;
using System.Windows.Forms;

namespace SIL.FieldWorks.Common.FwUtils
{
	/// ----------------------------------------------------------------------------------------
	/// <summary>
	/// Implements helper methods for invoking tasks on a specific thread, namely the thread this
	/// class was created on (which should typically be the main UI thread).
	/// </summary>
	/// <remarks>Unfortunately we have to create a Control, so we have to implement IDisposable
	/// to get rid of it again.</remarks>
	/// ----------------------------------------------------------------------------------------
	public sealed class ThreadHelper : ISynchronizeInvoke, IDisposable
	{
		/// <summary>Control to invoke methods that need to be run on this
		/// thread, but are called from another thread.</summary>
		private readonly Control m_invokeControl;

		/// ------------------------------------------------------------------------------------
		/// <summary>
		/// Initializes a new instance of the <see cref="ThreadHelper"/> class. Any calls to
		/// Invoke will be executed on the thread this class is created on, so this should
		/// typically be called on the main UI thread.
		/// </summary>
		/// ------------------------------------------------------------------------------------
		public ThreadHelper()
		{
			m_invokeControl = new Control();
			m_invokeControl.CreateControl();
		}

		#region Disposable stuff
		#if DEBUG
		/// <summary/>
		~ThreadHelper()
		{
			Dispose(false);
		}
		#endif

		/// <summary/>
		public bool IsDisposed { get; private set; }

		/// <summary/>
		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary/>
		private void Dispose(bool fDisposing)
		{
			System.Diagnostics.Debug.WriteLineIf(!fDisposing, "****** Missing Dispose() call for " + GetType() + " *******");
			if (fDisposing && !IsDisposed)
			{
				// dispose managed and unmanaged objects
				if (InvokeRequired)
					Invoke((MethodInvoker)(m_invokeControl.Dispose));
				else
					m_invokeControl.Dispose();
			}
			IsDisposed = true;
		}
		#endregion

		/// ------------------------------------------------------------------------------------
		/// <summary>
		/// Asynchronously executes the delegate on the thread that created this object.
		/// </summary>
		/// <param name="method">A <see cref="T:System.Delegate"/> to a method that takes parameters of the same number and type that are contained in <paramref name="args"/>.</param>
		/// <param name="args">An array of type <see cref="T:System.Object"/> to pass as arguments to the given method. This can be null if no arguments are needed.</param>
		/// <returns>
		/// An <see cref="T:System.IAsyncResult"/> interface that represents the asynchronous operation started by calling this method.
		/// </returns>
		/// ------------------------------------------------------------------------------------
		public IAsyncResult BeginInvoke(Delegate method, params object[] args)
		{
			return m_invokeControl.BeginInvoke(method, args);
		}

		/// ------------------------------------------------------------------------------------
		/// <summary>
		/// Waits until the process started by calling <see cref="M:System.ComponentModel.ISynchronizeInvoke.BeginInvoke(System.Delegate,System.Object[])"/> completes, and then returns the value generated by the process.
		/// </summary>
		/// <param name="result">An <see cref="T:System.IAsyncResult"/> interface that represents the asynchronous operation started by calling <see cref="M:System.ComponentModel.ISynchronizeInvoke.BeginInvoke(System.Delegate,System.Object[])"/>.</param>
		/// <returns>
		/// An <see cref="T:System.Object"/> that represents the return value generated by the asynchronous operation.
		/// </returns>
		/// ------------------------------------------------------------------------------------
		public object EndInvoke(IAsyncResult result)
		{
			return m_invokeControl.EndInvoke(result);
		}

		/// ------------------------------------------------------------------------------------
		/// <summary>
		/// Synchronously executes the delegate on the thread that created this object and marshals the call to the creating thread.
		/// </summary>
		/// <param name="method">A <see cref="T:System.Delegate"/> that contains a method to call, in the context of the thread for the control.</param>
		/// <param name="args">An array of type <see cref="T:System.Object"/> that represents the arguments to pass to the given method. This can be null if no arguments are needed.</param>
		/// <returns>
		/// An <see cref="T:System.Object"/> that represents the return value from the delegate being invoked, or null if the delegate has no return value.
		/// </returns>
		/// ------------------------------------------------------------------------------------
		public object Invoke(Delegate method, params object[] args)
		{
			return m_invokeControl.Invoke(method, args);
		}

		/// ------------------------------------------------------------------------------------
		/// <summary>
		/// Gets a value indicating whether an invoke is required from the calling thread. You
		/// don't normally need to check this, since Invoke takes care of doing it if needed.
		/// </summary>
		/// ------------------------------------------------------------------------------------
		public bool InvokeRequired
		{
			get { return m_invokeControl.InvokeRequired; }
		}



		/// ------------------------------------------------------------------------------------
		/// <summary>
		/// Displays a message box with the specified owner. If owner is null, then the currently
		/// active form is used. Any invoking that is required is handled.
		/// </summary>
		/// ------------------------------------------------------------------------------------
		public static DialogResult ShowMessageBox(Form owner, string text, string caption,
			MessageBoxButtons buttons, MessageBoxIcon icon)
		{
			// ENHANCE (TimS): From what I understand of Mono, it needs all forms to be shown on the
			// main UI thread. Using the owner or the active form should always be safe since they
			// were theoretically created on the main UI thread since Mono requires it.
			// However, there may be a problem when showing the message box without an owner
			// (i.e. realOwner == null) as it may attempt to show the message box on the
			// current thread. If this is a problem, we might have to make this method non-static
			// and invoke the showing of the message box using Invoke() on this ThreadHelper.
			Form realOwner = owner ?? Form.ActiveForm;
			if (realOwner == null)
				return MessageBox.Show(text, caption, buttons, icon);
			return (DialogResult)realOwner.Invoke((Func<DialogResult>)(() =>
				 MessageBox.Show(owner, text, caption, buttons, icon)));
		}
	}
}
